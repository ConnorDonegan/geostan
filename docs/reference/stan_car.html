<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Conditional autoregressive (CAR) models — stan_car • geostan</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/sandstone/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Conditional autoregressive (CAR) models — stan_car"><meta property="og:description" content="Use the CAR model as a prior on parameters, or fit data to an auto-Gaussian CAR model."><meta property="og:image" content="https://connordonegan.github.io/geostan/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-116873024-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-116873024-1');
</script></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">geostan</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.3.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/ConnorDonegan/geostan/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Conditional autoregressive (CAR) models</h1>
    <small class="dont-index">Source: <a href="https://github.com/ConnorDonegan/geostan/blob/HEAD/R/stan_car.R" class="external-link"><code>R/stan_car.R</code></a></small>
    <div class="hidden name"><code>stan_car.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Use the CAR model as a prior on parameters, or fit data to an auto-Gaussian CAR model.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">stan_car</span><span class="op">(</span>
  <span class="va">formula</span>,
  <span class="va">slx</span>,
  <span class="va">re</span>,
  <span class="va">data</span>,
  <span class="va">car_parts</span>,
  <span class="va">C</span>,
  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,
  prior <span class="op">=</span> <span class="cn">NULL</span>,
  ME <span class="op">=</span> <span class="cn">NULL</span>,
  centerx <span class="op">=</span> <span class="cn">FALSE</span>,
  prior_only <span class="op">=</span> <span class="cn">FALSE</span>,
  <span class="va">censor_point</span>,
  chains <span class="op">=</span> <span class="fl">4</span>,
  iter <span class="op">=</span> <span class="fl">2000</span>,
  refresh <span class="op">=</span> <span class="fl">500</span>,
  pars <span class="op">=</span> <span class="cn">NULL</span>,
  control <span class="op">=</span> <span class="cn">NULL</span>,
  <span class="va">...</span>
<span class="op">)</span></code></pre></div>
    </div>

    <div id="source">
    <h2>Source</h2>
    <p>Cressie, Noel (2015 (1993)). <em>Statistics for Spatial Data</em>. Wiley Classics, Revised Edition.</p>
<p>Cressie, Noel and Wikle, Christopher (2011). <em>Statistics for Spatio-Temporal Data</em>. Wiley.</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM" class="external-link">https://github.com/ConnorDonegan/survey-HBM</a>.</p>
<p>Donegan, Connor (2021). Spatial conditional autoregressive models in Stan. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65" class="external-link">doi:10.31219/osf.io/3ey65</a>
.</p>
<p>Haining, Robert and Li, Guangquan (2020). <em>Modelling Spatial and Spatial-Temporal Data: A Bayesian Approach</em>. CRC Press.</p>
    </div>
    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>formula</dt>
<dd><p>A model formula, following the R <code><a href="https://rdrr.io/r/stats/formula.html" class="external-link">formula</a></code> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p></dd>
<dt>slx</dt>
<dd><p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p></dd>
<dt>re</dt>
<dd><p>To include a varying intercept (or "random effects") term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:</p><div class="sourceCode"><pre><code>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</code></pre></div>

<p>With the CAR model, any <code>alpha_re</code> term should be at a <em>different</em> level or scale than the observations; that is, at a different scale than the autocorrelation structure of the CAR model itself.</p></dd>
<dt>data</dt>
<dd><p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p></dd>
<dt>car_parts</dt>
<dd><p>A list of data for the CAR model, as returned by <code><a href="prep_car_data.html">prep_car_data</a></code>.</p></dd>
<dt>C</dt>
<dd><p>Optional spatial connectivity matrix which will be used to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms; it will automatically be row-standardized before calculating <code>slx</code> terms. See <code><a href="shape2mat.html">shape2mat</a></code>.</p></dd>
<dt>family</dt>
<dd><p>The likelihood function for the outcome variable. Current options are <code><a href="auto_gaussian.html">auto_gaussian()</a></code>, <code>binomial(link = "logit")</code>, and <code>poisson(link = "log")</code>; if <code>family = gaussian()</code> is provided, it will automatically be converted to <code><a href="auto_gaussian.html">auto_gaussian()</a></code>.</p></dd>
<dt>prior</dt>
<dd><p>A named list of parameters for prior distributions (see <code><a href="priors.html">priors</a></code>):</p><dl><dt>intercept</dt>
<dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="priors.html">normal</a></code></p></dd>
.

<dt>beta</dt>
<dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.</p></dd>


<dt>car_scale</dt>
<dd><p>The scale of the CAR model, <code>car_scale</code>. The scale is assigned a Student's t prior model (constrained to be positive).</p></dd>


<dt>car_rho</dt>
<dd><p>The spatial autocorrelation parameter in the CAR model, <code>rho</code>, is assigned a uniform prior distribution. By default, the prior will be uniform over all permissible values as determined by the eigenvalues of the connectivity matrix, <code>C</code>. The range of permissible values for <code>rho</code> is automatically printed to the console by <code><a href="prep_car_data.html">prep_car_data</a></code>.</p></dd>


<dt>tau</dt>
<dd><p>The scale parameter for any varying intercepts (a.k.a exchangeable random effects, or partial pooling) terms. This scale parameter, <code>tau</code>, is assigned a Student's t prior (constrained to be positive).</p></dd>



</dl></dd>
<dt>ME</dt>
<dd><p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="prep_me_data.html">prep_me_data</a></code> function.</p></dd>
<dt>centerx</dt>
<dd><p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p></dd>
<dt>prior_only</dt>
<dd><p>Logical value; if <code>TRUE</code>, draw samples only from the prior distributions of parameters.</p></dd>
<dt>censor_point</dt>
<dd><p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths.</p></dd>
<dt>chains</dt>
<dd><p>Number of MCMC chains to use.</p></dd>
<dt>iter</dt>
<dd><p>Number of samples per chain.</p></dd>
<dt>refresh</dt>
<dd><p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Set <code>refresh=0</code> to silence this.</p></dd>
<dt>pars</dt>
<dd><p>Optional; specify any additional parameters you'd like stored from the Stan model.</p></dd>
<dt>control</dt>
<dd><p>A named list of parameters to control the sampler's behavior. See <code><a href="https://mc-stan.org/rstan/reference/stan.html" class="external-link">stan</a></code> for details.</p></dd>
<dt>...</dt>
<dd><p>Other arguments passed to <code><a href="https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html" class="external-link">sampling</a></code>. For multi-core processing, you can use <code>cores = parallel::detectCores()</code>, or run <code>options(mc.cores = parallel::detectCores())</code> first.</p></dd>
</dl></div>
    <div id="value">
    <h2>Value</h2>
    <p>An object of class class <code>geostan_fit</code> (a list) containing:</p><dl><dt>summary</dt>
<dd><p>Summaries of the main parameters of interest; a data frame.</p></dd>

<dt>diagnostic</dt>
<dd><p>Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (<code>eff_pars</code>) and mean log pointwise predictive density (<code>lpd</code>), and mean residual spatial autocorrelation as measured by the Moran coefficient.</p></dd>

<dt>stanfit</dt>
<dd><p>an object of class <code>stanfit</code> returned by <code><a href="https://mc-stan.org/rstan/reference/stan.html" class="external-link">rstan::stan</a></code></p></dd>

<dt>data</dt>
<dd><p>a data frame containing the model data</p></dd>

<dt>family</dt>
<dd><p>the user-provided or default <code>family</code> argument used to fit the model</p></dd>

<dt>formula</dt>
<dd><p>The model formula provided by the user (not including CAR component)</p></dd>

<dt>slx</dt>
<dd><p>The <code>slx</code> formula</p></dd>

<dt>re</dt>
<dd><p>A list containing <code>re</code>, the varying intercepts (<code>re</code>) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p></dd>

<dt>priors</dt>
<dd><p>Prior specifications.</p></dd>


<dt>x_center</dt>
<dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p></dd>


<dt>spatial</dt>
<dd><p>A data frame with the name of the spatial component parameter (either "phi" or, for auto Gaussian models, "trend") and method ("CAR")</p></dd>

<dt>ME</dt>
<dd><p>A list indicating if the object contains an ME model; if so, the user-provided ME list is also stored here.</p></dd>

<dt>C</dt>
<dd><p>Spatial connectivity matrix (in sparse matrix format).</p></dd>


</dl></div>
    <div id="details">
    <h2>Details</h2>
    <p>CAR models are discussed in Cressie and Wikle (2011, p. 184-88), Cressie (2015, Ch. 6-7), and Haining and Li (2020, p. 249-51).</p>
<p>The Stan code for this implementation of the CAR model first introduced in Donegan et al. (2021, supplementary material) for models of small area survey data.</p>
<p>Details and results depend on the <code>family</code> argument, as well as on the particular CAR specification chosen (see <a href="prep_car_data.html">prep_car_data</a>).</p><div class="section">
<h3 id="auto-gaussian">Auto-Gaussian<a class="anchor" aria-label="anchor" href="#auto-gaussian"></a></h3>


<p>When <code>family = auto_gaussian()</code>, the CAR model is specified as follows:</p><div class="sourceCode"><pre><code>Y ~ MVGauss(Mu, Sigma)
Sigma = (I - rho C)^-1 * M * tau^2
</code></pre></div>

<p>where <code>Mu</code> is the mean vector (with intercept, covariates, etc.), <code>C</code> is a spatial connectivity matrix, and <code>M</code> is a known diagonal matrix with diagonal entries proportional to the conditional variances. <code>C</code> and <code>M</code> are provided by <code><a href="prep_car_data.html">prep_car_data</a></code>.</p>
<p>The covariance matrix of the CAR model, <code>Sigma</code>, contains two parameters: <code>car_rho</code> (rho), which controls the degree of spatial autocorrelation, and the scale parameter, <code>car_scale</code> (tau). The range of permissible values for <code>rho</code> depends on the specification of <code>C</code> and <code>M</code>; for options, see <code><a href="prep_car_data.html">prep_car_data</a></code> and Cressie and Wikle (2011, pp. 184-188).</p>
<p>The auto-Gaussian model contains an implicit spatial trend (i.e., autocorrelation) component which is calculated as follows (Cressie 2015, p. 564):</p><div class="sourceCode"><pre><code>trend = rho * C * (Y - Mu).
</code></pre></div>

<p>This term can be extracted from a fitted auto-Gaussian model using the <code><a href="geostan_fit.html">spatial</a></code> method.</p>
<p>When applied to a fitted auto-Gaussian model, the <code><a href="geostan_fit.html">residuals.geostan_fit</a></code> method returns `de-trended' residuals by default. That is,</p><div class="sourceCode"><pre><code><span class="va">residual</span> <span class="op">=</span> <span class="va">Y</span> <span class="op">-</span> <span class="va">Mu</span> <span class="op">-</span> <span class="va">trend.</span></code></pre></div>

<p>To obtain "raw" residuals (<code>Y - Mu</code>), use <code>residuals(fit, detrend = FALSE)</code>.</p>
</div>

<div class="section">
<h3 id="poisson">Poisson<a class="anchor" aria-label="anchor" href="#poisson"></a></h3>


<p>For <code>family = poisson()</code>, the model is specified as:</p><div class="sourceCode"><pre><code>Y ~ Poisson(exp(offset + lambda))
lambda ~ MVGauss(Mu, Sigma)
Sigma = (I - rho C)^-1 * M * tau^2
</code></pre></div>

<p>These models are most often used to calculate small area incidence rates (mortality or disease incidence rates); the user provided offset should be, then, the natural logarithm of the denominator in the rates, e.g., log-population at risk.</p>
<p>For Poisson models, the <code><a href="geostan_fit.html">spatial</a></code> method returns the parameter vector <code>phi</code>, which is the log-risk minus the intercept and any covariates:</p><div class="sourceCode"><pre><code><span class="va">phi</span> <span class="op">=</span> <span class="va">lambda</span> <span class="op">-</span> <span class="va">Mu.</span></code></pre></div>

<p>This is the spatial autocorrelation component. This is equivalent to specifying the model as:</p><div class="sourceCode"><pre><code>Y ~ Poisson(exp(offset + Mu + phi))
phi ~ MVGauss(0, Sigma)
Sigma = (I - rho C)^-1 * M * tau^2.
</code></pre></div>

<p>In the Poisson CAR model, <code>phi</code> contains a latent spatial trend as well as additional variation around it. If you would like to extract the latent/implicit spatial trend from <code>phi</code>, you can do so by calculating (following Cressie 2015, p. 564):</p><div class="sourceCode"><pre><code><span class="va">trend</span> <span class="op">=</span> <span class="va">rho</span> <span class="op">*</span> <span class="va">C</span> <span class="op">*</span> <span class="va">phi.</span></code></pre></div>

</div>

<div class="section">
<h3 id="binomial">Binomial<a class="anchor" aria-label="anchor" href="#binomial"></a></h3>


<p>For <code>family = binomial()</code>, the model is specified as:</p><div class="sourceCode"><pre><code>Y ~ Binomial(N, theta)
logit(theta) ~ MVGauss(Mu, Sigma)
Sigma = (I - rho C)^-1 * M * tau^2
</code></pre></div>

<p>where outcome data <code>Y</code> are counts, <code>N</code> is the number of trials, and <code>theta</code> is the 'success' rate. Note that the model formula should be structured as: <code>cbind(sucesses, failures) ~ x</code>, such that <code>trials = successes + failures</code>.</p>
<p>For fitted Binomial models, the <code><a href="geostan_fit.html">spatial</a></code> method will return the parameter vector <code>phi</code>, equivalent to:</p><div class="sourceCode"><pre><code><span class="va">phi</span> <span class="op">=</span> <span class="fu">logit</span><span class="op">(</span><span class="va">theta</span><span class="op">)</span> <span class="op">-</span> <span class="va">Mu.</span></code></pre></div>

</div>

<div class="section">
<h3 id="spatially-lagged-covariates-slx-">Spatially lagged covariates (SLX)<a class="anchor" aria-label="anchor" href="#spatially-lagged-covariates-slx-"></a></h3>


<p>The <code>slx</code> argument is a convenience function for including SLX terms. For example,</p><div class="sourceCode"><pre><code>stan_glm(y ~ x1 + x2, slx = ~ x1, \...)
</code></pre></div>

<p>is a shortcut for</p><div class="sourceCode"><pre><code>stan_glm(y ~ I(W \%*\% x1) + x1 + x2, \...)
</code></pre></div>

<p>where <code>W</code> is a row-standardized spatial weights matrix (see <code><a href="shape2mat.html">shape2mat</a></code>). SLX terms will always be <em>prepended</em> to the design matrix, as above, which is important to know when setting prior distributions for regression coefficients.</p>
<p>For measurement error (ME) models, the SLX argument is the only way to include spatially lagged covariates since the SLX term needs to be re-calculated on each iteration of the MCMC algorithm.</p>
</div>

<div class="section">
<h3 id="measurement-error-me-models">Measurement error (ME) models<a class="anchor" aria-label="anchor" href="#measurement-error-me-models"></a></h3>


<p>The ME models are designed for surveys with spatial sampling designs, such as the American Community Survey (ACS) estimates. With estimates, <code>x</code>, and their standard errors, <code>se</code>, the ME models have one of the the following two specifications, depending on the user input:</p><div class="sourceCode"><pre><code>x ~ Gauss(x_true, se)
x_true ~ MVGauss(mu, Sigma)
Sigma = (I - rho C)^(-1) M * tau^2
mu ~ Gauss(0, 100)
tau ~ student_t(10, 0, 40)
rho ~ uniform(lower_bound, upper_bound)
</code></pre></div>

<p>where the covariance matrix, <code>Sigma</code>, has the conditional autoregressive specification, and <code>tau</code> is the scale parameter. For non-spatial ME models, the following is used instead:</p><div class="sourceCode"><pre><code><span class="va">x</span> <span class="op">~</span> <span class="fu">Gauss</span><span class="op">(</span><span class="va">x_true</span>, <span class="va">se</span><span class="op">)</span>
<span class="va">x_true</span> <span class="op">~</span> <span class="fu"><a href="../reference/priors.html">student_t</a></span><span class="op">(</span><span class="va">df</span>, <span class="va">mu</span>, <span class="va">sigma</span><span class="op">)</span>
<span class="va">df</span> <span class="op">~</span> <span class="fu"><a href="../reference/priors.html">gamma</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">0.2</span><span class="op">)</span>
<span class="va">mu</span> <span class="op">~</span> <span class="fu">Gauss</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">100</span><span class="op">)</span>
<span class="va">sigma</span> <span class="op">~</span> <span class="fu"><a href="../reference/priors.html">student_t</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">0</span>, <span class="fl">40</span><span class="op">)</span></code></pre></div>

<p>For strongly skewed variables, such census tract poverty rates, it can be advantageous to apply a logit transformation to <code>x_true</code> before applying the CAR or Student t prior model. When the <code>logit</code> argument is used, the model becomes:</p><div class="sourceCode"><pre><code><span class="va">x</span> <span class="op">~</span> <span class="fu">Gauss</span><span class="op">(</span><span class="va">x_true</span>, <span class="va">se</span><span class="op">)</span>
<span class="fu">logit</span><span class="op">(</span><span class="va">x_true</span><span class="op">)</span> <span class="op">~</span> <span class="fu">MVGauss</span><span class="op">(</span><span class="va">mu</span>, <span class="va">Sigma</span><span class="op">)</span></code></pre></div>

<p>and similar for the Student t model.</p>
</div>

<div class="section">
<h3 id="censored-counts">Censored counts<a class="anchor" aria-label="anchor" href="#censored-counts"></a></h3>


<p>Vital statistics systems and disease surveillance programs typically suppress case counts when they are smaller than a specific threshold value. In such cases, the observation of a censored count is not the same as a missing value; instead, you are informed that the value is an integer somewhere between zero and the threshold value. For Poisson models (<code>family = poisson())</code>), you can use the <code>censor_point</code> argument to encode this information into your model.</p>
<p>Internally, <code>geostan</code> will keep the index values of each censored observation, and the index value of each of the fully observed outcome values. For all observed counts, the likelihood statement will be:</p><div class="sourceCode"><pre><code>p(y_i | data, model) = Poisson(y_i | fitted_i), 
</code></pre></div>

<p>as usual. For each censored count, the likelihood statement will equal the cumulative Poisson distribution function for values zero through the censor point:</p><div class="sourceCode"><pre><code>p(y_j | data, model) = sum_{m=0}^censor_point Poisson( c_m | fitted_j),
</code></pre></div>

<p>For example, the US Centers for Disease Control and Prevention's CDC WONDER database censors all death counts between 0 and 9. To model CDC WONDER mortality data, you could provide <code>censor_point = 9</code> and then the likelihood statement for censored counts would equal the summation of the Poisson probability mass function over each integer ranging from zero through 9 (inclusive), conditional on the fitted values (i.e., all model parameters). See Donegan (2021) for additional discussion, references, and Stan code.</p>
</div>

    </div>
    <div id="author">
    <h2>Author</h2>
    <p>Connor Donegan, <a href="mailto:Connor.Donegan@UTDallas.edu">Connor.Donegan@UTDallas.edu</a></p>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span class="co"># \donttest{</span></span>
<span class="r-in"><span class="co"># for automatic parallel processing</span></span>
<span class="r-in"><span class="co">#options(mc.cores = parallel::detectCores())</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># model mortality rates</span></span>
<span class="r-in"><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">georgia</span><span class="op">)</span></span>
<span class="r-in"><span class="va">C</span> <span class="op">&lt;-</span> <span class="fu"><a href="shape2mat.html">shape2mat</a></span><span class="op">(</span><span class="va">georgia</span>, style <span class="op">=</span> <span class="st">"B"</span><span class="op">)</span></span>
<span class="r-in"><span class="va">cp</span> <span class="op">&lt;-</span> <span class="fu"><a href="prep_car_data.html">prep_car_data</a></span><span class="op">(</span><span class="va">C</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Range of permissible rho values:  -1.661134 1 </span>
<span class="r-in"></span>
<span class="r-in"><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu">stan_car</span><span class="op">(</span><span class="va">deaths.male</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/offset.html" class="external-link">offset</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">pop.at.risk.male</span><span class="op">)</span><span class="op">)</span>,</span>
<span class="r-in">                car_parts <span class="op">=</span> <span class="va">cp</span>,</span>
<span class="r-in">                data <span class="op">=</span> <span class="va">georgia</span>,</span>
<span class="r-in">                family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior parameters for intercept</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: normal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   location scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1     -4.2     5</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior for CAR scale parameter (car_scale)</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: student_t</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   df location scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 10        0     3</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior for CAR spatial autocorrelation parameter (rho)</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: uniform</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lower upper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1  -1.7     1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 1).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Gradient evaluation took 9.8e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.98 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:  Elapsed Time: 1.18641 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:                1.19602 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:                2.38243 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 2).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Gradient evaluation took 8.6e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.86 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:  Elapsed Time: 1.16507 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:                1.18346 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:                2.34853 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 3).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Gradient evaluation took 0.0001 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 1 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:  Elapsed Time: 1.1403 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:                1.18058 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:                2.32088 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 4).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Gradient evaluation took 8.5e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.85 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:  Elapsed Time: 1.09923 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:                1.17217 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:                2.2714 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">rstan</span><span class="fu">::</span><span class="fu"><a href="https://mc-stan.org/rstan/reference/stan_plot_diagnostics.html" class="external-link">stan_rhat</a></span><span class="op">(</span><span class="va">fit</span><span class="op">$</span><span class="va">stanfit</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</span>
<span class="r-plt img"><img src="stan_car-1.png" alt="" width="700" height="433"></span>
<span class="r-in"><span class="fu">rstan</span><span class="fu">::</span><span class="fu"><a href="https://mc-stan.org/rstan/reference/stan_plot_diagnostics.html" class="external-link">stan_mcse</a></span><span class="op">(</span><span class="va">fit</span><span class="op">$</span><span class="va">stanfit</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</span>
<span class="r-plt img"><img src="stan_car-2.png" alt="" width="700" height="433"></span>
<span class="r-in"><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Spatial Model Results </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Formula: deaths.male ~ offset(log(pop.at.risk.male))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;environment: 0x556fa7fd2190&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Spatial method (outcome):  CAR </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Likelihood function:  poisson </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Link function:  log </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Residual Moran Coefficient:  -0.0028555 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> WAIC:  1319.13 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Observations:  159 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Data models (ME): none</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Inference for Stan model: foundation.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4 chains, each with iter=2000; warmup=1000; thin=1; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> post-warmup draws per chain=1000, total post-warmup draws=4000.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             mean se_mean    sd   2.5%    25%    50%    75%  97.5% n_eff  Rhat</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> intercept -4.169   0.002 0.078 -4.333 -4.207 -4.168 -4.127 -4.021  2597 1.001</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> car_rho    0.904   0.001 0.069  0.737  0.869  0.916  0.956  0.992  3357 1.000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> car_scale  0.470   0.000 0.034  0.407  0.447  0.468  0.492  0.542  4806 1.000</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Samples were drawn using NUTS(diag_e) at Thu Jul  7 19:25:48 2022.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> For each parameter, n_eff is a crude measure of effective sample size,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> and Rhat is the potential scale reduction factor on split chains (at </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> convergence, Rhat=1).</span>
<span class="r-in"><span class="fu"><a href="sp_diag.html">sp_diag</a></span><span class="op">(</span><span class="va">fit</span>, <span class="va">georgia</span><span class="op">)</span></span>
<span class="r-plt img"><img src="stan_car-3.png" alt="" width="700" height="433"></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># censored count outcomes</span></span>
<span class="r-in"><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">georgia</span><span class="op">$</span><span class="va">deaths.female</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 3</span>
<span class="r-in"><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu">stan_car</span><span class="op">(</span><span class="va">deaths.female</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/offset.html" class="external-link">offset</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">pop.at.risk.female</span><span class="op">)</span><span class="op">)</span>,</span>
<span class="r-in">                car_parts <span class="op">=</span> <span class="va">cp</span>,</span>
<span class="r-in">                data <span class="op">=</span> <span class="va">georgia</span>,</span>
<span class="r-in">                family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span class="r-in">                censor_point <span class="op">=</span> <span class="fl">9</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior parameters for intercept</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: normal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   location scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1     -4.7     5</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior for CAR scale parameter (car_scale)</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: student_t</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   df location scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 10        0     3</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior for CAR spatial autocorrelation parameter (rho)</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: uniform</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lower upper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1  -1.7     1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 1).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Gradient evaluation took 9.3e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.93 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:  Elapsed Time: 1.34771 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:                1.25843 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:                2.60614 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 2).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Gradient evaluation took 9.7e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.97 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:  Elapsed Time: 1.64647 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:                1.14119 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:                2.78766 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 3).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Gradient evaluation took 9.3e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.93 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:  Elapsed Time: 1.34171 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:                1.23562 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:                2.57733 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 4).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Gradient evaluation took 9.1e-05 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.91 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:  Elapsed Time: 1.19872 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:                1.24486 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:                2.44358 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## DCAR specification (inverse-distance based)</span></span>
<span class="r-in"><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/" class="external-link">sf</a></span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE</span>
<span class="r-in"><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="shape2mat.html">shape2mat</a></span><span class="op">(</span><span class="va">georgia</span>, <span class="st">"B"</span><span class="op">)</span></span>
<span class="r-in"><span class="va">D</span> <span class="op">&lt;-</span> <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html" class="external-link">st_distance</a></span><span class="op">(</span><span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html" class="external-link">st_centroid</a></span><span class="op">(</span><span class="va">georgia</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>st_centroid assumes attributes are constant over geometries of x</span>
<span class="r-in"><span class="va">A</span> <span class="op">&lt;-</span> <span class="va">D</span> <span class="op">*</span> <span class="va">A</span></span>
<span class="r-in"><span class="va">cp</span> <span class="op">&lt;-</span> <span class="fu"><a href="prep_car_data.html">prep_car_data</a></span><span class="op">(</span><span class="va">A</span>, <span class="st">"DCAR"</span>, k <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> &lt;sparse&gt;[ &lt;logic&gt; ] : .M.sub.i.logical() maybe inefficient</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Range of permissible rho values:  -0.6761887 0.3471584 </span>
<span class="r-in"></span>
<span class="r-in"><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu">stan_car</span><span class="op">(</span><span class="va">deaths.male</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/offset.html" class="external-link">offset</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">pop.at.risk.male</span><span class="op">)</span><span class="op">)</span>,</span>
<span class="r-in">               data <span class="op">=</span> <span class="va">georgia</span>,</span>
<span class="r-in">               car <span class="op">=</span> <span class="va">cp</span>,</span>
<span class="r-in">               family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Consider providing the matrix C explicitly using the C argument. The matrix C is used for calculating spatial-lag of X (SLX) terms and residual spatial autocorrelation. Since you did not provide C, the matrix is being taken from car_parts$C.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior parameters for intercept</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: normal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   location scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1     -4.2     5</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior for CAR scale parameter (car_scale)</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: student_t</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   df location scale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 10        0     3</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> *Setting prior for CAR spatial autocorrelation parameter (rho)</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Distribution: uniform</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lower upper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 -0.68  0.35</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 1).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Gradient evaluation took 0.000182 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.82 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:  Elapsed Time: 2.3973 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:                2.10358 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1:                4.50088 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 1: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 2).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Gradient evaluation took 0.000135 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 1.35 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:  Elapsed Time: 2.00214 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:                2.58082 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2:                4.58296 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 2: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 3).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Gradient evaluation took 0.000159 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 1.59 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:  Elapsed Time: 2.31716 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:                2.42687 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3:                4.74403 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 3: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SAMPLING FOR MODEL 'foundation' NOW (CHAIN 4).</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Gradient evaluation took 0.000155 seconds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 1.55 seconds.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Adjust your expectations accordingly!</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration:  500 / 2000 [ 25%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 1500 / 2000 [ 75%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:  Elapsed Time: 2.10494 seconds (Warm-up)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:                2.02848 seconds (Sampling)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4:                4.13342 seconds (Total)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Chain 4: </span>
<span class="r-in"><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Spatial Model Results </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Formula: deaths.male ~ offset(log(pop.at.risk.male))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;environment: 0x556fa7fd2190&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Spatial method (outcome):  CAR </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Likelihood function:  poisson </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Link function:  log </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Residual Moran Coefficient:  -0.00406525 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> WAIC:  1319.35 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Observations:  159 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Data models (ME): none</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Inference for Stan model: foundation.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4 chains, each with iter=2000; warmup=1000; thin=1; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> post-warmup draws per chain=1000, total post-warmup draws=4000.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             mean se_mean    sd   2.5%    25%    50%    75%  97.5% n_eff Rhat</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> intercept -4.122       0 0.042 -4.201 -4.151 -4.123 -4.094 -4.039  8220    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> car_rho    0.328       0 0.016  0.285  0.321  0.332  0.340  0.346  5358    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> car_scale  0.469       0 0.033  0.408  0.447  0.468  0.490  0.541  5053    1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Samples were drawn using NUTS(diag_e) at Thu Jul  7 19:26:30 2022.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> For each parameter, n_eff is a crude measure of effective sample size,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> and Rhat is the potential scale reduction factor on split chains (at </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> convergence, Rhat=1).</span>
<span class="r-in"><span class="co"># }</span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Connor Donegan.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.1.</p>
</div>

      </footer></div>

  


  

  </body></html>

