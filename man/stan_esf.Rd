% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stan_esf.R
\name{stan_esf}
\alias{stan_esf}
\title{Spatial filtering}
\source{
Chun, Y., D. A. Griffith, M. Lee and P. Sinha (2016). Eigenvector selection with stepwise regression techniques to construct eigenvector spatial filters. \emph{Journal of Geographical Systems}, 18(1), 67-85. \doi{10.1007/s10109-015-0225-3}.

Dray, S., P. Legendre & P. R. Peres-Neto (2006). Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM). \emph{Ecological Modeling}, 196(3-4), 483-493.

Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moranâ€™s Eigenvectors and hierarchical shrinkage priors. \emph{Spatial Statistics}. \doi{10.1016/j.spasta.2020.100450}.

Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. \emph{Int. J. Env. Res. and Public Health} 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: \url{https://github.com/ConnorDonegan/survey-HBM}.

Griffith, Daniel A., and P. R. Peres-Neto (2006). Spatial modeling in ecology: the flexibility of eigenfunction spatial analyses. \emph{Ecology} 87(10), 2603-2613.

Griffith, D., and Y. Chun (2014). Spatial autocorrelation and spatial filtering, Handbook of Regional Science. Fischer, MM and Nijkamp, P. eds.

Griffith, D., Chun, Y. and Li, B. (2019). \emph{Spatial Regression Analysis Using Eigenvector Spatial Filtering}. Elsevier.

Piironen, J and A. Vehtari (2017). Sparsity information and regularization in the horseshoe and other shrinkage priors. In \emph{Electronic Journal of Statistics}, 11(2):5018-5051. \doi{10.1214/17-EJS1337SI}.
}
\usage{
stan_esf(
  formula,
  slx,
  re,
  data,
  C,
  nsa = FALSE,
  threshold = 0.25,
  EV = make_EV(C, nsa = nsa, threshold = threshold),
  ME = NULL,
  family = gaussian(),
  p0,
  prior = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  pars = NULL,
  control = NULL,
  ...
)
}
\arguments{
\item{formula}{A model formula, following the R \link[stats]{formula} syntax. Binomial models are specified by setting the left hand side of the equation to a data frame of successes and failures, as in \code{cbind(successes, failures) ~ x}.}

\item{slx}{Formula to specify any spatially-lagged covariates. As in, \code{~ x1 + x2} (the intercept term will be removed internally).

These will be pre-multiplied by a row-standardized version of the user-provided spatial weights matrix and then added (prepended) to the design matrix. For example, providing\preformatted{stan_esf(y ~ x1 + x2, slx = ~ x1, ...)
}

is the same as providing\preformatted{stan_esf(y ~ I(W \%*\% x1) + x1 + x2, ...)
}

where \code{W} is a row-standardized spatial weights matrix (see \code{\link[geostan]{shape2mat}}). When setting priors for \code{beta}, remember to include priors for any SLX terms as well.}

\item{re}{To include a varying intercept (or "random effects") term, \code{alpha_re}, specify the grouping variable here using formula syntax, as in \code{~ ID}. Then, \code{alpha_re} is a vector of parameters added to the linear predictor of the model, and:\preformatted{       alpha_re ~ N(0, alpha_tau)
       alpha_tau ~ Student_t(d.f., location, scale).
}}

\item{data}{A \code{data.frame} or an object coercible to a data frame by \code{as.data.frame} containing the model data.}

\item{C}{Spatial connectivity matrix which will be used to calculate eigenvectors, if \code{EV} is not provided by the user. Typically, the binary connectivity matrix is best for calculating eigenvectors (i.e., using \code{C = shape2mat(shape, style = "B")} rather than \code{style = "W"}). This matrix will also be used to calculate residual spatial autocorrelation and any user specified \code{slx} terms; it will be row-standardized before calculating \code{slx} terms. See \code{\link[geostan]{shape2mat}}.}

\item{nsa}{Include eigenvectors representing negative spatial autocorrelation? Defaults to \code{nsa = FALSE}. This is ignored if \code{EV} is provided.}

\item{threshold}{Eigenvectors with standardized Moran coefficient values below this \code{threshold} value will be excluded from the candidate set of eigenvectors, \code{EV}. This defaults to \code{threshold = 0.25}, and is ignored if \code{EV} is provided.}

\item{EV}{A matrix of eigenvectors from any (transformed) connectivity matrix, presumably spatial. With connectivity matrix \code{C}, you can create \code{EV} using \code{EV = make_EV(C)}. If \code{EV} is provided, still also provide a spatial weights matrix \code{C} for other purposes.  See \code{\link[geostan]{make_EV}} and \code{\link[geostan]{shape2mat}}.}

\item{ME}{To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a named list. The ME models are designed for American Community Survey (ACS) estimates, \code{x}, and their standard errors, \code{se} (Donegan, Chun and Griffith 2021). The ME models have one of the the following two specifications, depending on the user input:\preformatted{      x ~ Gauss(x_true, se)
      x_true ~ MVGauss(mu, Sigma)
      Sigma = (I - rho * C)^(-1) M * tau^2
      mu ~ Gauss(0, 100)
      tau ~ student_t(10, 0, 40)
      rho ~ uniform(lower_bound, upper_bound)
}

where the covariance matrix, \code{Sigma}, has the conditional autoregressive specification, and \code{tau} is the scale parameter. If \code{ME$car_parts} is not provided by the user, then a non-spatial model will be used instead:\preformatted{       x ~ Gauss(x_true, se)
       x_true ~ student_t(df, mu, sigma)
       df ~ gamma(3, 0.2)
       mu ~ Gauss(0, 100)
       sigma ~ student_t(10, 0, 40)
}

The target of inference is \code{x_true}, the actual values of the covariate during the period of the survey, and the observational error is the difference between the survey estimate and the unknown value that would have been obtained by a complete census. Elements of the list \code{ME} may include:

\describe{

\item{se}{A required dataframe with standard errors for each observation; columns will be matched to the variables by column names. The names should match those from the output of \code{model.matrix(formula, data)}.}

\item{bounds}{An optional numeric vector of length two providing the upper and lower bounds, respectively, of the variables. If not provided, they will be set to \code{c(-Inf, Inf)} (i.e., unbounded). Common usages include keeping percentages between zero and one hundred or proportions between zero and one.}

\item{prior}{Optionally provide parameter values for the prior distributions of the measurement error model(s). The ME models contain a location parameter (mu) and a scale parameter (tau or sigma), each of which require prior distributions. If none are provided, default priors will be assigned and printed to the console. \cr \cr

The prior for the location parameter, mu, is Gaussian (the default being \code{Gauss(0, 100)}). You can alter this by providing a \code{data.frame} with columns named \code{location} and \code{scale}; provide values for each covariate in \code{se}. List the values in the same order as the columns of \code{se}. \cr \cr

The prior for the location parameter, mu, is Gaussian (the default being \code{Gauss(0, 100)}). You can alter this by providing a \code{data.frame} with columns named \code{location} and \code{scale}; provide values for each covariate in \code{se}. List the values in the same order as the columns of \code{se}. \cr \cr

For example, if you are modeling two covariates with the ME models, you can add the priors to an existing \code{ME} list like this:\preformatted{ME$prior <- list(location = data.frame(location = c(0, 0),
                                          scale = c(10, 10)),
                 scale = c(40, 40))
}

Note that if a prior is provided, you must provide priors for both location (mu) and scale (tau or sigma). \cr \cr

The CAR model also has a spatial autocorrelation parameter, \code{rho}, which is assigned a uniform prior distribution. You can set the boudaries of the prior with:\preformatted{ME$prior$car_rho <- c(lower_bound, upper_bound)
}

You must specify values that are within the permissible range of values for \code{rho}. This range is automatically printed to the console by \code{\link[geostan]{prep_car_data}}.
}

\item{car_parts}{A list of data for the CAR model, as returned by \link[geostan]{prep_car_data}. If not provided, a non-spatial Student's t model will be used instead of the CAR model.}
}}

\item{family}{The likelihood function for the outcome variable. Current options are \code{family = gaussian()}, \code{student_t()} and \code{poisson(link = "log")}, and \code{binomial(link = "logit")}.}

\item{p0}{Optional; number of eigenvector coefficients expected to be far from zero. If this and \code{prior_rhs} are missing, Chun et al.'s (2016) formula will be used to fill this in using \code{\link[geostan]{exp_pars}}. The value of \code{p0} is used to control the prior degree of sparsity in the model.}

\item{prior}{A named list of parameters for prior distributions. User-defined priors can be assigned to the following parameters:
\describe{
\item{intercept}{The intercept is assigned a Gaussian prior distribution; provide a numeric vector with location and scale parameters; e.g. \code{prior = list(intercept = c(location = 0, scale = 10))} to assign a Gaussian prior with mean zero and variance 10^2.}

\item{beta}{Regression coefficients are assigned Gaussian prior distributions. Provide a \code{data.frame} with two columns (location and scale).

The order of variables must follow their order of appearance in the model \code{formula}; e.g., if the formula is \code{y ~ x1 + x2}, then providing\preformatted{prior = list(beta = data.frame(location = c(0, 2),
                                  scale = c(1, 2)))
}

will assign the following prior distributions:\preformatted{       x1 ~ Gauss(0, 1)
       x2 ~ Gauss(2, 2)
}

Note that if you also use \code{slx} terms (spatially lagged covariates), then you have to provide priors for them. If your model specification is:\preformatted{ stan_glm(y ~ x1 + x2, slx = ~ x1, ...)
}

then the prior for beta must have three rows. Since slx terms are always \emph{prepended} to the design matrix, the prior for the slx term will be listed first.
}

\item{sigma}{The scale parameter, \verb{sigma,} for \code{gaussian()} and \code{student_t()} models is assigned a half-Student's t prior distribution. Thus, provide values for the degrees of freedom, location, and scale parameters; e.g., \code{prior = list(sigma = c(df = 10, location = 0, scale = 5))} for a prior centered on zero with scale of 5 and 10 degrees of freedom. The half-Student's t prior for \code{sigma} is constrained to be positive.
}

\item{nu}{The degrees of freedom for the Student's t likelihood model is assigned a gamma prior distribution. The default prior is \code{prior = list(nu = c(alpha = 3, beta = 0.2))}.}

\item{tau}{The scale parameter for random effects, or varying intercepts, terms. This scale parameter, \code{tau}, is assigned a half-Student's t prior. To set this, use, e.g., \code{prior = list(tau = c(df = 20, location = 0, scale = 20))}.}

\item{rhs}{This is for controlling the regularized horseshoe (RHS) prior, which is assigned to the eigenvector coefficients. Provide a \emph{named} vector of length three. The RHS prior has two parts to consider. First is the 'slab' that is used to regularize large coefficient estimates; this is a zero-mean Student's t model, the user provides the degrees of freedom and scale parameters. The second component is the global shrinkage parameter, controlling the degree of shrinkage; provide a value nearer to zero if you wish to make the model more sparse. To allow the spatial filter to account for a greater amount of spatial autocorrelation (i.e., if you find the residuals contain spatial autocorrelation), increase the global scale parameter up to one. E.g., \code{prior = list(rhs = c(slab_df = 15, slab_scale = 5, scale_global = 1))}.}
}}

\item{centerx}{To center predictors on their mean values, use \code{centerx = TRUE}. If \code{centerx} is a numeric vector, predictors will be centered on the values provided. This argument is passed to \code{\link[base]{scale}}.}

\item{prior_only}{Draw samples from the prior distributions of parameters only.}

\item{chains}{Number of MCMC chains to estimate. Default \code{chains = 4}.}

\item{iter}{Number of samples per chain. Default \code{iter = 2000}.}

\item{refresh}{Stan will print the progress of the sampler every \code{refresh} number of samples. Defaults to \code{500}; set \code{refresh=0} to silence this.}

\item{pars}{Optional; specify any additional parameters you'd like stored from the Stan model. Parameters from the RHS priors include \code{tau} (the global shrinkage parameter) and \code{lambda} (the local shrinkage parameter).}

\item{control}{A named list of parameters to control the sampler's behavior. See \link[rstan]{stan} for details.}

\item{...}{Other arguments passed to \link[rstan]{sampling}.}
}
\value{
An object of class class \code{geostan_fit} (a list) containing:
\describe{
\item{summary}{Summaries of the main parameters of interest; a data frame}
\item{diagnostic}{Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (\code{eff_pars}) and mean log pointwise predictive density (\code{lpd}), and mean residual spatial autocorrelation as measured by the Moran coefficient.}
\item{data}{a data frame containing the model data}
\item{EV}{A matrix of eigenvectors created with \code{w} and \code{geostan::make_EV}}
\item{C}{The spatial weights matrix used to construct EV}
\item{family}{the user-provided or default \code{family} argument used to fit the model}
\item{formula}{The model formula provided by the user (not including ESF component)}
\item{slx}{The \code{slx} formula}
\item{re}{A list containing \code{re},  the random effects (varying intercepts) formula if provided, and
\code{data} a data frame with columns \code{id}, the grouping variable, and \code{idx}, the index values assigned to each group.}
\item{priors}{Prior specifications.}
\item{x_center}{If covariates are centered internally (i.e., \code{centerx} is not \code{FALSE}), then \code{x_centers} is the numeric vector of values on which the covariates were centered.}
\item{ME}{The \code{ME} data list, if one was provided by the user for measurement error models.}
\item{spatial}{A data frame with the name of the spatial component parameter ("esf") and method ("ESF")}
\item{stanfit}{an object of class \code{stanfit} returned by \code{rstan::stan}}
}
}
\description{
Fit a spatial regression model using eigenvector spatial filtering (ESF).
}
\details{
Eigenvector spatial filtering (ESF) is a method for spatial regression analysis. ESF is extensivly covered in Griffith et al. (2019). This function implements the methodology introduced in Donegan et al. (2020), which uses Piironen and Vehtari's (2017) regularized horseshoe prior.

ESF models take the spectral decomposition of a transformed spatial connectivity matrix, \code{C}. The resulting eigenvectors, \code{EV}, are mutually orthogonal and uncorrelated map patterns. ESF decomposes spatial autocorrelation into a linear combination of various patterns, typically at different scales (such as local, regional, and global trends). By adding a spatial filter to a regression model, any spatial autocorrelation is shifted from the residuals to the spatial filter. The spatail filter is \code{EV * beta_ev}, where \code{beta_ev} is a vector of coefficients.

ESF decomposes the data into a global mean, \code{alpha}, global patterns contributed by covariates, \code{X * beta}, spatial trends, \code{EV * beta_ev}, and residual variation. Thus, for \code{family=gaussian()},\preformatted{                         Y ~ Gauss(alpha + X * beta + EV * beta_ev, sigma).
}

An ESF component can be incorporated into the linear predictor of any generalized linear model. For example, a spatial Poisson model for rare disease incidence may be specified as follows:\preformatted{                          Y ~ Poisson(exp(offset + Mu))
                          Mu = alpha + A + EV * beta_ev
                          A ~ Guass(0, tau)
                          tau ~ student(20, 0, 2)
                          beta_ev ~ horseshoe(.)
}

The \link[geostan]{spatial} method will return \code{EV * beta}.

The model can also be extended to the space-time domain; see \link[geostan]{shape2mat} to specify a space-time connectivity matrix.

The coefficients \code{beta_ev} are assigned the regularized horseshoe prior (Piironen and Vehtari, 2017), resulting in a relatively sparse model specification. In addition, numerous eigenvectors are automatically dropped because they represent trace amounts of spatial autocorrelation (this is controlled by the \code{threshold} argument). By default, \code{stan_esf} will drop all eigenvectors representing negative spatial autocorrelation patterns. You can change this behavior using the \code{nsa} argument.
}
\examples{
\dontrun{
library(ggplot2)
library(sf)
library(bayesplot)
data(sentencing)

# spatial weights matrix with binary coding scheme
C <- shape2mat(sentencing, style = "B")

# log-expected number of sentences
## expected counts are based on county racial composition and mean sentencing rates
log_e <- log(sentencing$expected_sents)

# fit spatial Poisson model with ESF + unstructured 'random effects'
fit.esf <- stan_esf(sents ~ offset(log_e),
                   re = ~ name,
                   family = poisson(),
                   data = sentencing,
                   C = C,
                   refresh = 0
)

# spatial diagnostics 
sp_diag(fit.esf, sentencing)

# plot marginal posterior distributions of beta_ev (eigenvector coefficients)
plot(fit.esf, pars = "beta_ev")

# plot the marginal posterior distributions of the spatial filter (ESF * beta_ev)
plot(fit.esf, pars = "beta_ev")

# posterior predictive distribution
yrep <- posterior_predict(fit.esf, samples = 75)
y <- sentencing$sents
bayesplot::ppc_dens_overlay(y, yrep) 

# map the spatial filter
sp.filter <- spatial(fit.esf)$mean
st_as_sf(sentencing) \%>\%
 ggplot() +
 geom_sf(aes(fill = sp.filter)) +
 scale_fill_gradient2()

# calculate log-standardized sentencing ratios (log-SSRs)
f <- fitted(fit.esf)$mean
SSR <-  f / sentencing$expected_sents
log.SSR <- log( SSR, base = 2 )

# map the log-SSRs
st_as_sf(sentencing) \%>\%
 ggplot() +
 geom_sf(aes(fill = log.SSR)) +
 scale_fill_gradient2(
   midpoint = 0,
   name = NULL,
   breaks = seq(-3, 3, by = 0.5)
 ) +
 labs(title = "Log-Standardized Sentencing Ratios",
      subtitle = "log( Fitted/Expected ), base 2"
 ) +
 theme_void() +
 theme(
   legend.position = "bottom",
   legend.key.height = unit(0.35, "cm"),
   legend.key.width = unit(1.5, "cm")
 )

} 

}
\author{
Connor Donegan, \email{Connor.Donegan@UTDallas.edu}
}
