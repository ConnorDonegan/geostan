% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stan_icar.R
\name{stan_icar}
\alias{stan_icar}
\title{Intrinsic autoregressive models}
\source{
Besag, J. (1974). Spatial interaction and the statistical analysis of lattice systems. Journal of the Royal Statistical Society: Series B (Methodological), 36(2), 192-225.

Besag, J., York, J., & Mollié, A. (1991). Bayesian image restoration, with two applications in spatial statistics. Annals of the institute of statistical mathematics, 43(1), 1-20.

Donegan, Connor. 2021. Flexible functions for ICAR, BYM, and BYM2 models in Stan. Code repository. \url{https://github.com/ConnorDonegan/Stan-IAR}

Freni-Sterrantino, Anna, Massimo Ventrucci, and Håvard Rue. 2018. A Note on Intrinsic Conditional Autoregressive Models for Disconnected Graphs. Spatial and Spatio-Temporal Epidemiology 26: 25–34.

Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., & DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan. Spatial and spatio-temporal epidemiology, 31, 100301.

Riebler, A., Sorbye, S. H., Simpson, D., & Rue, H. (2016). An intuitive Bayesian spatial model for disease mapping that accounts for scaling. Statistical Methods in Medical Research, 25(4), 1145-1165.
}
\usage{
stan_icar(
  formula,
  slx,
  re,
  data,
  C,
  type = c("icar", "bym", "bym2"),
  scale_factor = NULL,
  ME = NULL,
  family = poisson(),
  prior = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  pars = NULL,
  control = list(adapt_delta = 0.9, max_treedepth = 13),
  ...
)
}
\arguments{
\item{formula}{A model formula, following the R \link[stats]{formula} syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in \code{cbind(successes, failures) ~ x}.}

\item{slx}{Formula to specify any spatially-lagged covariates. As in, \code{~ x1 + x2} (the intercept term will be removed internally).
These will be pre-multiplied by a row-standardized spatial weights matrix and then added (prepended) to the design matrix.
If and when setting priors for \code{beta} manually, remember to include priors for any SLX terms as well.}

\item{re}{If the model includes a varying intercept term, \code{alpha_re}, specify the grouping variable here using formula syntax, as in \code{~ ID}. Then, \code{alpha_re ~ N(0, alpha_tau)}, \code{alpha_tau ~ Student_t(d.f., location, scale)}. Before using this, read the \code{Details} section and the \code{type} argument.}

\item{data}{A \code{data.frame} or an object coercible to a data frame by \code{as.data.frame} containing the model data.}

\item{C}{Spatial connectivity matrix which will be used to construct an edge list for the ICAR model, and to calculate residual spatial autocorrelation as well as any user specified \code{slx} terms or spatial measurement error (ME) models. It will automatically be row-standardized before calculating \code{slx} terms. \code{C} must be a binary symmetric \code{n x n} matrix.}

\item{type}{Defaults to "icar" (partial pooling of neighboring observations through parameter \code{phi}); specify "bym" to add a second parameter vector \code{theta} to perform partial pooling across all observations; specify "bym2" for the innovation introduced by Riebler et al. (2016). See \code{Details} for more information.}

\item{scale_factor}{For the BYM2 model, optional. If missing, this will be set to a vector of ones. See \code{Details}.}

\item{ME}{To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a named list. Errors are assigned a Gaussian probability distribution and the modeled (true) covariate vector is assigned a Student's t model or, if \code{ME$spatial = TRUE}, an auto Gaussian (CAR) model. Elements of the list \code{ME} may include:
\describe{

\item{se}{a dataframe with standard errors for each observation; columns will be matched to the variables by column names. The names should match those from the output of \code{model.matrix(formula, data)}.}
\item{bounded}{If any variables in \code{se} are bounded within some range (e.g. percentages ranging from zero to one hundred) provide a vector of zeros and ones indicating which columns are bounded. By default the lower bound will be 0 and the upper bound 100, for percentages.}
\item{bounds}{A numeric vector of length two providing the upper and lower bounds, respectively, of any bounded variables.}

\item{prior}{Provide parameter values for the prior distributions of the measurement error model(s). The spatial conditional autoregressive (CAR) and non-spatial student's t models both contain a location parameter (the mean) and a scale parameter, each of which require prior distributions. If none are provided, default priors will be assigned and printed to the console.

To set these priors to custom values, provide a named list with items \code{location} and \code{scale} (you must provide both). The prior for the location parameter is Gaussian, the default being \code{Gauss(0, 100)}. To change these values, provide a \code{data.frame} with columns named \code{location} and \code{scale}. Provide prior specifications for each covariate in \code{se}; list the priors in the same order as the columns of \code{se}.

The prior for the \code{scale} parameters is Student's t, and the default is \code{Student_t(10, 0, 40)}. The degrees of freedom (10) and mean (zero) are fixed, but you can alter the scale by providing a vector of values in the same order as the columns of \code{se}.

For example, \code{ME$prior <- list(location = data.frame(location = c(0, 0), scale = c(100, 100)), scale = c(40, 40))}.}

\item{spatial}{Logical value indicating whether an auto Gaussian (i.e., conditional autoregressive (CAR)) model should be used for the covariates. For \code{stan_icar}, this defaults to \code{spatial = TRUE}; if \code{spatial = TRUE} you must provide \code{car_parts} (see below).}

\item{car_parts}{A list of data for the CAR model, as returned by \link[geostan]{prep_car_data} (be sure to return the matrix \code{C}, by using the argument \code{cmat = TRUE}). Only required if \code{spatial=TRUE}.}
}}

\item{family}{The likelihood function for the outcome variable. Current options are \code{binomial(link = "logit")} and \code{poisson(link = "log")}.}

\item{prior}{A named list of parameters for prior distributions. User-defined priors can be assigned to the following parameters:
\describe{

\item{intercept}{The intercept is assigned a Gaussian prior distribution; provide a numeric vector with location and scale parameters; e.g. \code{prior = list(intercept = c(location = 0, scale = 10))} to assign a Gaussian prior with mean zero and variance 10^2.}

\item{beta}{Regression coefficients are assigned Gaussian prior distributions. Provide a \code{data.frame} with two columns (location and scale).

The order of variables must follow their order of appearance in the model \code{formula}; e.g., if the formula is \code{y ~ x1 + x2}, then providing \verb{prior = list(beta = data.frame(location = c(0, 5), scale = c(1, 10))) will assign standard normal prior distributions to the coefficient on }x1\verb{; the prior for }x2\verb{would be}Gaussian(5, 10)`.

Note that if you also use \code{slx} terms (spatially lagged covariates), then you have to provide priors for them; \code{slx} terms \emph{precede} other terms in the model formula. For example, providing of \code{y ~ x1 + x2} with \code{slx = ~ x1 + x2} is the same as providing \verb{formula = y ~ I(W \\\%*\\\% x1) + I(W \\\%*\\\% x2) + x1 + x2}, where \code{W} is a row-standardized spatial weights matrix (see \code{\link[geostan]{shape2mat}}).}

\item{alpha_tau}{The scale parameter for random effects, or varying intercepts, terms. This scale parameter, \code{tau}, is assigned a half-Student's t prior. To set this, use, e.g., \code{prior = list(alpha_tau = c(df = 20, location = 0, scale = 20))}.}
}}

\item{centerx}{To center predictors, provide either a logical value (TRUE, FALSE) or numeric-alike vector of length equal to the number of columns of ‘x’, where ‘numeric-alike’ means that ‘as.numeric(.)’ will be applied successfully if ‘is.numeric(.)’ is not true. Passed to \code{\link[base]{scale}}.}

\item{prior_only}{Draw samples from the prior distributions of parameters only.}

\item{chains}{Number of MCMC chains to estimate.}

\item{iter}{Number of samples per chain. .}

\item{refresh}{Stan will print the progress of the sampler every \code{refresh} number of samples; set \code{refresh=0} to silence this.}

\item{pars}{Optional; specify any additional parameters you'd like stored from the Stan model.}

\item{control}{A named list of parameters to control the sampler's behavior. See \link[rstan]{stan} for details. The defaults are the same \code{rstan::stan} except that \code{adapt_delta} is raised to \code{.9} and \code{max_treedepth = 15}.}

\item{...}{Other arguments passed to \link[rstan]{sampling}. For multi-core processing, you can use \code{cores = parallel::detectCores()}, or run \code{options(mc.cores = parallel::detectCores())} first.}
}
\value{
An object of class class \code{geostan_fit} (a list) containing:
\describe{
\item{summary}{Summaries of the main parameters of interest; a data frame}
\item{diagnostic}{Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (\code{eff_pars}) and mean log pointwise predictive density (\code{lpd}), and mean residual spatial autocorrelation as measured by the Moran coefficient.}
\item{stanfit}{an object of class \code{stanfit} returned by \code{rstan::stan}}
\item{data}{a data frame containing the model data}
\item{edges}{The edge list representing all unique sets of neighbors and the weight attached to each pair (i.e., their corresponding element in the connectivity matrix  C}
\item{family}{the user-provided or default \code{family} argument used to fit the model}
\item{formula}{The model formula provided by the user (not including ICAR component)}
\item{slx}{The \code{slx} formula}
\item{re}{A list with two name elements, \code{formula} and \code{Data}, containing the formula \code{re} and a data frame with columns \code{id} (the grouping variable) and \code{idx} (the index values assigned to each group).}
\item{priors}{Prior specifications.}
\item{x_center}{If covariates are centered internally (i.e., \code{centerx} is not \code{FALSE}), then \code{x_centers} is the numeric vector of values on which the covariates were centered.}
\item{spatial}{A data frame with the name of the spatial parameter (\code{"phi"} if \code{type = "icar"} else \code{"convolution"}) and method (\code{toupper(type)}).}
}
}
\description{
The intrinsic conditional auto-regressive (ICAR) model for spatial count data. Options include the BYM model, the BYM2 model, and a solo ICAR term.
}
\details{
The Stan code for the ICAR component of the model and the BYM2 option is from Morris et al. (2019) with adjustments to enable non-binary weights and disconnected graph structures (see Freni-Sterrantino (2018) and Donegan (2021)).

The exact specification depends on the \code{type} argument.
\subsection{\code{type = 'icar'}}{

For Poisson models for count data, y, the basic model specification (\code{type = "icar"}) is:\preformatted{             y ~ Poisson(exp(offset + mu + phi))
             phi ~ ICAR(spatial_scale)
             spatial_scale ~ Gaussian(0, 1)
}

where \code{mu} contains an intercept and potentially covariates. The spatial trend, \code{phi}, has a mean of zero and a single scale parameter, \code{spatial_scale}.

The ICAR prior model is a CAR model that has a spatial autocorrelation parameter \code{car_alpha} equal to 1 (see \link[geostan]{stan_car}). Thus the ICAR prior places high probability on a smooth spatially (or temporally) varying mean. This is rarely sufficient to model the amount of variation present in social and health data.
}

\subsection{\code{type = 'bym'}}{

Often, an observational-level random effect term, \code{theta}, is added to capture (heterogeneous or unstructured) deviations from \code{mu + phi}. The combined term is referred to as a convolution term:\preformatted{             convolution = phi + theta.
}

This is known as the BYM model (Besag et al. 1991), and can be specified using \code{type = "bym"}:\preformatted{             y ~ Poisson(exp(offset + mu + phi + theta))
             phi ~ ICAR(spatial_scale)
             theta ~ Gaussian(0, theta_scale)
             spatial_scale ~ Gaussian(0, 1)
             theta_scale ~ Gaussian(0, 1)
}
}

\subsection{\code{type = 'bym2'}}{

Riebler et al. (2016) introduce a variation on the BYM model (\code{type = "bym2"}). This specification combines \code{phi} and \code{theta} using a mixing parameter, \code{rho}, that controls the proportion of the variation that is attributable to the spatially autocorrelated term, \code{phi}, rather than the spatially unstructured term, \code{theta}. The terms share a single scale parameter:\preformatted{             convolution = [sqrt(rho/scale_factor) * phi_tilde + sqrt(1 - rho) * theta_tilde] * spatial_scale.
             phi_tilde ~ Gaussian(0, 1)
             theta_tilde ~ Gaussian(0, 1)
             spatial_scale ~ Gaussian(0, 1)
}

The two \verb{_tilde} terms are standard normal deviates, \code{rho} is restricted to values between zero and one, and \code{scale_factor} is a constant term provided by the user. By default, \code{scale_factor} is equal to one, so that it does nothing. Riebler et al. (2016) argue that the interpretation or meaning of the scale of the ICAR model depends on the graph structure, \code{C}. This implies that the same prior distribution assigned to the \code{spatial_scale} will differ in its implications if \code{C} is changed; in other words, the priors are not transportable across models, and models that use the same nominal prior actually have different priors assigned to \code{spatial_scale}.

Borrowing \code{R} code from Morris (2017) and following Freni-Sterrantino et al. (2018), the following \code{R} code can be used to create the \code{scale_factor} for the BYM2 model (note, this requires the INLA R package), given a spatial adjacency matrix, C:\preformatted{              ## create a list of data for stan_icar
              icar.data <- geostan::prep_icar_data(C)
              ## calculate scale_factor for each of k connected group of nodes
              k <- icar.data$k
              scale_factor <- vector(mode = "numeric", length = k)
              for (j in 1:k) \{
                g.idx <- which(icar.data$comp_id == j) 
                if (length(g.idx) == 1) \{
                  scale_factor[j] <- 1
                  next
                 \}    
              Cg <- C[g.idx, g.idx] 
              scale_factor[j] <- scale_c(Cg) 
              \}
}

This code adjusts for 'islands' or areas with zero neighbors, and it also handles disconnected graph structures (see Donegan 2021). Following Freni-Sterrantino (2018), disconnected components of the graph structure are given their own intercept term; however, this value is added to \code{phi} automatically inside the Stan model. Therefore, the user never needs to make any adjustments for this term. (If you want to avoid complications from a disconnected graph structure, see \code{\link[geostan]{stan_car}}).

Note, the code above requires the \code{scale_c} function; it has package dependencies that are not included in \code{geostan}. To use \code{scale_c}, you have to load the following \code{R} function:\preformatted{#' compute scaling factor for adjacency matrix, accounting for differences in spatial connectivity 
#'
#' @param C connectivity matrix
#'
#' @details
#'
#' Requires the following packages: 
#'
#' library(Matrix)
#' library(INLA);
#' library(spdep)
#' library(igraph)
#'  
#' @source
#'
#'   Morris, Mitzi (2017). Spatial Models in Stan: Intrinsic Auto-Regressive Models for Areal Data. <https://mc-stan.org/users/documentation/case-studies/icar_stan.html>
#'
scale_c <- function(C) \{
 geometric_mean <- function(x) exp(mean(log(x))) 
 N = dim(C)[1]
 Q =  Diagonal(N, rowSums(C)) - C
 Q_pert = Q + Diagonal(N) * max(diag(Q)) * sqrt(.Machine$double.eps)
 Q_inv = inla.qinv(Q_pert, constr=list(A = matrix(1,1,N),e=0))
 scaling_factor <- geometric_mean(Matrix::diag(Q_inv)) 
 return(scaling_factor) 
\}
}
}
}
\examples{
\dontrun{
library(rstan)
library(sf)
options(mc.cores = parallel::detectCores())
data(sentencing)

C <- shape2mat(sentencing, "B")
log_e <- log(sentencing$expected_sents)
fit.bym <- stan_icar(sents ~ offset(log_e),
                     family = poisson(),
                     data = sentencing,
                     type = "bym",
                     C = C
 )

# check effective sample size and convergence
rstan::stan_ess(fit.bym$stanfit)
rstan::stan_rhat(fit.bym$stanfit)

# see some spatial diagnostics
sp_diag(fit.bym, sentencing)

# map the smooth spatial term
sp.trend <- spatial(fit.bym)$mean
ggplot( st_as_sf(sentencing) ) +
  geom_sf(aes(fill = sp.trend)) +
  scale_fill_gradient2() +
  theme_void()

# calculate log-standardized sentencing ratios (log-SSRs)
## (like Standardized Incidence Ratios: observed/exected case counts)
f <- fitted(fit.bym)$mean
SSR <- f / sentencing$expected_sents
log.SSR <- log( SSR, base = 2)

ggplot( st_as_sf(sentencing) ) +
  geom_sf(aes(fill = log.SSR)) +
  scale_fill_gradient2() +
  labs(title = "Log-standardized sentencing ratios",
       subtitle = "log( Fitted/Expected), base 2") +
  theme_void() +
  theme(
   legend.position = "bottom",
   legend.key.height = unit(0.35, "cm"),
   legend.key.width = unit(1.5, "cm")
  )
}

}
\seealso{
\link[geostan]{prep_icar_data}, \link[geostan]{shape2mat}, \link[geostan]{stan_car}, \link[geostan]{stan_esf}, \link[geostan]{stan_glm}
}
\author{
Connor Donegan, \email{Connor.Donegan@UTDallas.edu}
}
